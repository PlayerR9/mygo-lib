package main

import (
	"flag"
	"log"
	"os"
	"text/template"

	"github.com/PlayerR9/mygo-lib/common"
	ggen "github.com/PlayerR9/mygo-lib/generator"
)

var (
	t      *template.Template
	logger *log.Logger
)

func init() {
	t = template.Must(template.New("treenode").Parse(templ))
	logger = ggen.NewLogger("treenode")
}

var (
	DestLoc *string
)

func init() {
	DestLoc = flag.String("o", "treenode.go", "Destination file. If not set, defaults to 'treenode.go'")
}

type Gen struct {
	PackageName string
}

func (g *Gen) SetPackageName(pkg_name string) error {
	if g == nil {
		return common.ErrNilReceiver
	}

	g.PackageName = pkg_name

	return nil
}

func main() {
	flag.Parse()

	if *DestLoc == "" {
		*DestLoc = "treenode.go"
	}

	data, err := ggen.Generate(t, *DestLoc, &Gen{})
	if err != nil {
		logger.Fatalf("failed to generate: %v", err)
	}

	err = os.WriteFile(*DestLoc, data, 0644)
	if err != nil {
		logger.Fatalf("failed to write file: %v", err)
	} else {
		logger.Printf("Sucessfully generated %s", *DestLoc)
	}
}

const templ string = `
import common "github.com/PlayerR9/mygo-lib/common"

type Node struct {
	// Parent, FirstChild, LastChild, NextSibling, PrevSibling are all the
	// pointers required for traversing the tree.
	Parent, FirstChild, LastChild, NextSibling, PrevSibling *Node

	// [Add more fields here...]
}

// String implements the fmt.Stringer interface.
func (n Node) String() string {
	return "Node[ [Write the fields here...] ]"
}

// NewNode creates a new node with the given fields.
//
// Parameters:
//   - [Write the parameters here...]
//
// Returns:
//   - *Node: The new node. Never returns nil.
func NewNode(/* [Write the fields here...] */) *Node {
	return &Node{
		/* [Write the fields here...] */
	}
}

// IsNil checks whether the node is nil or not.
//
// Returns:
//   - bool: True if the node is nil, false otherwise.
func (n *Node) IsNil() bool {
	return n == nil
}

// IsLeaf checks whether the node is a leaf node or not.
//
// Returns:
//   - bool: True if the node is a leaf node, false otherwise.
func (n Node) IsLeaf() bool {
	return n.FirstChild == nil
}

// Child iterates over the children of the node from the first child to the
// last child.
//
// Returns:
//   - iter.Seq[*Node[T]]: An iterator over the children of the node. Never
//     returns nil.
func (n Node) Child() iter.Seq[*Node] {
	return func(yield func(*Node) bool) {
		for child := n.FirstChild; child != nil; child = child.NextSibling {
			if !yield(child) {
				break
			}
		}
	}
}

// BackwardChild is like Child but iterates from the last child to the first
// child.
//
// Returns:
//   - iter.Seq[*Node[T]]: An iterator over the children of the node. Never
//     returns nil.
func (n Node) BackwardChild() iter.Seq[*Node] {
	return func(yield func(*Node) bool) {
		for child := n.LastChild; child != nil; child = child.PrevSibling {
			if !yield(child) {
				break
			}
		}
	}
}

func RejectNils(children []*Node) []*Node {
	if len(children) == 0 {
		return nil
	}

	var count int

	for _, n := range children {
		if n == nil {
			count++
		}
	}

	if count == 0 {
		return nil
	}

	slice := make([]*Node, 0, count)

	for _, n := range children {
		if n != nil {
			slice = append(slice, n)
		}
	}

	return slice
}

func link_children(parent *Node, children []*Node) []*Node {
	for _, n := range children {
		n.Parent = parent
	}

	prev := children[0]

	for _, n := range children[1:] {
		n.PrevSibling = prev
		prev.NextSibling = n
		prev = n
	}

	return children
}

func (n *Node) AppendChildren(children ...*Node) error {
	children = RejectNils(children)
	if len(children) == 0 {
		return nil
	} else if n == nil {
		return common.ErrNilReceiver
	}

	children = link_children(n, children)

	if n.FirstChild == nil {
		n.FirstChild = children[0]
	} else {
		n.LastChild.NextSibling = children[0]
		children[0].PrevSibling = n.LastChild
	}

	n.LastChild = children[len(children)-1]

	return nil
}`
